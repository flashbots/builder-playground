package playground

import (
	"encoding/json"
	"os"
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core"
	"github.com/stretchr/testify/require"
)

func TestEnodeGeneration(t *testing.T) {
	// Test that the enodes generated by output are deterministic
	o1 := newTestOutput(t)
	o2 := newTestOutput(t)

	for i := 0; i < 10; i++ {
		if o1.GetEnodeAddr().NodeID() != o2.GetEnodeAddr().NodeID() {
			t.Fatalf("enode IDs are not the same")
		}
	}
}

func TestPrefundedAccounts_Default(t *testing.T) {
	o := newTestOutput(t)

	b := NewArtifactsBuilder()
	b.WithL2()
	require.NoError(t, b.Build(o))

	prefundedAccount := common.HexToAddress("0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266")

	l1Genesis := readGenesis(t, o, "l2-genesis.json")
	l2Genesis := readGenesis(t, o, "genesis.json")

	// both genesis must have 10 prefunded accounts and the prefundedAccount' '0xf39..'
	for _, genesis := range []*core.Genesis{l1Genesis, l2Genesis} {
		alloc, ok := genesis.Alloc[prefundedAccount]
		require.True(t, ok)
		require.Equal(t, alloc.Balance, prefundedBalance)
	}
}

func TestPrefundedAccounts_Custom(t *testing.T) {
	o := newTestOutput(t)

	customPrivKey := "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
	customAddress := common.HexToAddress("0x1Be31A94361a391bBaFB2a4CCd704F57dc04d4bb")

	b := NewArtifactsBuilder().PrefundedAccounts([]string{customPrivKey}).WithL2()
	require.NoError(t, b.Build(o))

	l1Genesis := readGenesis(t, o, "genesis.json")
	l2Genesis := readGenesis(t, o, "l2-genesis.json")

	// both genesis must have the custom prefunded account
	for _, genesis := range []*core.Genesis{l1Genesis, l2Genesis} {
		alloc, ok := genesis.Alloc[customAddress]
		require.True(t, ok)
		require.Equal(t, alloc.Balance, prefundedBalance)
	}
}

func readGenesis(t *testing.T, o *output, genesisName string) *core.Genesis {
	genesisRaw, err := o.Read(genesisName)
	require.NoError(t, err)

	var genesis core.Genesis
	require.NoError(t, json.Unmarshal([]byte(genesisRaw), &genesis))

	return &genesis
}

func TestPredeploys_Custom(t *testing.T) {
	o := newTestOutput(t)

	// Create a temporary predeploys JSON file
	predeployAddr := common.HexToAddress("0x1234567890abcdef1234567890abcdef12345678")
	predeployCode := []byte{0x60, 0x80, 0x60, 0x40} // Simple bytecode
	predeploysJSON := `{
		"0x1234567890abcdef1234567890abcdef12345678": {
			"balance": "0x0",
			"code": "0x60806040"
		}
	}`

	tmpFile, err := os.CreateTemp("", "predeploys-*.json")
	require.NoError(t, err)
	defer os.Remove(tmpFile.Name())

	_, err = tmpFile.WriteString(predeploysJSON)
	require.NoError(t, err)
	require.NoError(t, tmpFile.Close())

	b := NewArtifactsBuilder().WithL2().PredeployFile(tmpFile.Name())
	require.NoError(t, b.Build(o))

	l2Genesis := readGenesis(t, o, "l2-genesis.json")

	// Verify the predeploy is in L2 genesis
	alloc, ok := l2Genesis.Alloc[predeployAddr]
	require.True(t, ok, "predeploy address should be in L2 genesis")
	require.Equal(t, predeployCode, alloc.Code, "predeploy code should match")
}

func newTestOutput(t *testing.T) *output {
	dir, err := os.MkdirTemp("/tmp", "test-output")
	if err != nil {
		t.Fatalf("failed to create temporal folder: %v", err)
	}
	defer os.RemoveAll(dir)

	o := &output{
		dst: dir,
	}
	return o
}
